---
title: "Microbiome assessment for *A. cervicornis* microplastics project (16S and ITS2)"
date: "*Last run on `r format(Sys.time(), '%d %B %Y')`*"
output: 
  html_document:
    theme: simplex
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
---

<style>
  h2{color: #DC7633 !important}
  h1{color: #5499C7 !important}
  body{background-color: white !important}
</style>

<style>
.list-group-item.active, .list-group-item.active:hover, .list-group-item.active:focus {
    color: #212F3D;
    background-color: #EDBB99;
    font-weight: bold;}
a {
    color: #5499C7;}
.nav-tabs > li.active > a, .nav-tabs > li.active > a:hover, .nav-tabs > li.active > a:focus {
    color: #DC7633;}
body {
    font-family: "Open Sans","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-size: 13px;
    line-height: 1.42857143;
    color: #212F3D;}
</style>


```{r set some defaults, echo = FALSE}

library("knitr")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
pdf.options(useDingbats = FALSE)

```

```{r install packages, eval = FALSE, include = FALSE}

## Downloading DADA2 following instructions found here:
# https://benjjneb.github.io/dada2/dada-installation.html

# these instructions for the SCC and MacBook Pro (2020)
install.packages("devtools")
library("devtools")
devtools::install_github("benjjneb/dada2", ref="v1.20", force = TRUE) # change the ref argument to get other versions


## install phyloseq packages
install.packages("Biostrings")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(version = "3.15") # Bioconductor version '3.14' requires R version '4.1'; use `BiocManager::install(version = '3.15')` with R version 4.2; see https://bioconductor.org/install
BiocManager::install("phyloseq")


## used for removing contamination from neg controls
BiocManager::install("decontam")


BiocManager::install("microbiome")
#remotes::install_github("r-lib/rlang")

## used for the diversity metrics of 16S
devtools::install_github("awhstin/awtools")

## facet label colours
devtools::install_github("teunbrand/ggh4x")

```

```{r load packages, echo = FALSE}

library(dada2) # I have version 1.18.0 downloaded on the SCC for this
library(tidyverse)
library(ShortRead)
library(kableExtra)
library(phyloseq)
library(decontam)
library(RColorBrewer)
library(plotly)
library(vegan)
library(janitor)
library(MCMC.OTU)
library(ggpubr)
library(microbiome)
library(Biostrings)
library(awtools)
library(performance)
library(car)
library(lme4)
library(patchwork)
library(compositions)
library(ggh4x) 
library(shades)

```

```{r setup standards}

## Set the treatment colours:
trt_col <- c("dodgerblue", "darkorange","firebrick2", "firebrick4")

## Set genotype shapes:
gen_shape <- c(21, 22, 23, 24, 25)


## Sourcing functions from external R scripts
source("Misc_functions/other_functions.R") # some custom functions 
source("Misc_functions/ancom.R") # these are the ANCOM functions

```

<br/>

# **16S Assessment**

I am largely following the [DADA2](https://www.bioconductor.org/packages/release/bioc/manuals/dada2/man/dada2.pdf) tutorial by Benjamin Callahan that can be found [here](https://benjjneb.github.io/dada2/tutorial.html). 


## Inspecting the data {.tabset}

```{r set path to 16S samples}

## the directory containing the fastq files after unzipping (ifelse will set  path specific to working on SCC vs locally)
wd <- getwd()

if(length(grep("Dropbox", wd)) > 0) {
  path_16S <- "/Users/colleen/Dropbox/BU/DaviesLab/ACER_microplastics/16S_fastq" 
} else {
  path_16S <- "/projectnb/davieslab/bove/acer_MP/final_samples/16S_29Jun22" 
}

# looks good! need to specify only using the microplastic samples
# list.files(path_16S)

```

```{r extract fastq files and sample names}

# Forward and reverse fastq filenames have format: SAMPLENAME_R1.fastq and SAMPLENAME_R2.fastq
fnFs <- sort(list.files(path_16S, pattern = "_R1.fastq", full.names = TRUE))
fnRs <- sort(list.files(path_16S, pattern = "_R2.fastq", full.names = TRUE))

# Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
sample_names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1)

```

### Check samples to use

```{r select only microplastic samples}

# list of samples to keep (removed failed RNA preps, low counts, and clones)
keep_samples <- c("10aA - 1", "5aC - 2", "10aB - 1", "6D - 1", "5aC - 1", "6B - 2", "5B - 1", "5aE - 1", "2E - 1", "2B - 1", "6B - 1", "10aC - 1", "5aA - 1", "5D - 1", "5C - 1", "10aD - 1", "5C - 2", "2D - 1", "6E - 1", NA)


## read in the meta data from the samples
meta <- read.csv("Data/Acerv_MP_Metadata.csv") %>% 
  #filter(Genotype %in% keep_samples) %>% # select for only the GE-matching samples
  separate(Genotype, c("Genotype", "Frag"), sep = "(?=[A-Z])") 


# filter the sample name list to select neg controls and microplastic samples only
sample_names <- sample_names[sample_names %in% meta$sampleID]
sample_names

# reordering these so they match the order of sample names 
meta <- meta[match(sample_names, meta$sampleID),] 
rownames(meta) <- meta$sampleID


# filter the forward sequences for microplastics only
fnFs <- fnFs %>% 
  str_detect("/A|/B|/C|G5|G6", negate = FALSE) %>%
  keep(fnFs, .)

# filter the reverse sequences for microplastics only
fnRs <- fnRs %>% 
  str_detect("/A|/B|/C|G5|G6", negate = FALSE) %>%
  keep(fnRs, .)

```


```{r set some standards for checking primers, include=FALSE}

#### check for primers ####
FWD <- "GTGYCAGCMGCCGCGGTAA"  ## CHANGE ME to your forward primer sequence
REV <- "GGACTACNVGGGTWTCTAAT"  ## CHANGE ME...

FWD.orients <- allOrients(FWD)
REV.orients <- allOrients(REV)

```

```{r double check for primers left, eval=FALSE, include=FALSE}

## create list of forward/reverse samples from filters
fnFs_filtN <- file.path(path_16S, "filtN", basename(fnFs)) # Put N-filterd files in filtN/ subdirectory
fnRs_filtN <- file.path(path_16S, "filtN", basename(fnRs))

## filter/trim the samples
filterAndTrim(fnFs, fnFs_filtN, fnRs, fnRs_filtN, maxN = 0, multithread = TRUE)


#towards the beginning
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs_filtN[[1]]), 
      FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs_filtN[[1]]), 
      REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs_filtN[[1]]), 
      REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs_filtN[[1]]))

#at the end
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs_filtN[[4]]), 
      FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs_filtN[[4]]), 
      REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs_filtN[[4]]), 
      REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs_filtN[[4]]))

```

```{r remove the extra primers that were left, eval=FALSE, include=FALSE}

## Install cutadapt to local computer and set path here (python3 -m pip install --user --upgrade cutadapt)
cutadapt = "/Users/colleen/Library/Python/3.9/bin/cutadapt"
system2(cutadapt, args = "--version")

## look for cutadapt path and create one if it doesn't exist
path_cut <- file.path(path_16S, "cutadapt")
if(!dir.exists(path_cut)) dir.create(path_cut)

## create list of forward/reverse samples to put the cutadapt samples
fnFs_cut <- file.path(path_cut, basename(fnFs)) # 16S path with the subdirectory 'cutadapt' then the sample names
fnRs_cut <- file.path(path_cut, basename(fnRs))

# forward/reverse complements of primers
FWD_RC <- dada2:::rc(FWD)
REV_RC <- dada2:::rc(REV)

R1_flags <- paste("-g", FWD, "-a", REV_RC) # Trim FWD and the reverse-complement of REV off of R1 (forward reads)
R2_flags <- paste("-G", REV, "-A", FWD_RC) # Trim REV and the reverse-complement of FWD off of R2 (reverse reads)

# Run Cutadapt
for(i in seq_along(fnFs)) {
  system2(cutadapt, args = c(R1_flags, R2_flags, "-n", 2, # -n 2 required to remove FWD and REV from reads
                             "-o", fnFs_cut[i], "-p", fnRs_cut[i], # output files
                             fnFs_filtN[i], fnRs_filtN[i])) # input files
}

#towards the beginning
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs_cut[[1]]), 
      FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs_cut[[1]]), 
      REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs_cut[[1]]), 
      REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs_cut[[1]]))

#at the end
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs_cut[[4]]), 
      FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnRs_cut[[4]]), 
      REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs_cut[[4]]), 
      REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnRs_cut[[4]]))

# no more primers were detected after this second cutadapt step

```

<br/>
<br/>


### View example quality plots

Viewing the quality of 2 of the forward samples
```{r firward quality plots, fig.height = 4, fig.width = 6}

fnFs_cut <- file.path(path_16S, "cutadapt", paste0(sample_names, "_16S_R1.fastq")) # 16S path with the subdirectory 'cutadapt' then the sample names
fnRs_cut <- file.path(path_16S, "cutadapt", paste0(sample_names, "_16S_R2.fastq"))


## Plot 2 samples for examples:
plotQualityProfile(fnFs_cut[1:2])

```

Viewing the quality of the same 2 of the reverse samples
```{r reverse quality plots, fig.height = 4, fig.width = 6}

## Plot 2 reverse samples for examples:
plotQualityProfile(fnRs_cut[1:2])

```

```{r eval=FALSE, include=FALSE}

## Saving the quality profiles of all (except sample A1) to view later if necessary
Fs_qualityPlot <- plotQualityProfile(fnFs_cut)

png(file = "Figures/Exploratory/Forward_qualityPlots.png", width = 30, height = 23, res = 1200, unit = "cm")
Fs_qualityPlot
dev.off()


## Saving the quality profiles of all to view later if necessary
Rs_qualityPlot <- plotQualityProfile(fnRs_cut)

png(file = "Figures/Exploratory/Reverse_qualityPlots.png", width = 30, height = 23, res = 1200, unit = "cm")
Rs_qualityPlot
dev.off()

```

<br/>
<br/>


## Filter and trim samples {.tabset}

### Perform the filtering

You can see in above figures that the quality of reads drop off towards the end, so we need to filter out these low quality reads

```{r filtering low quality reads}

# Place filtered files in filtered/ subdirectory
filtFs <- file.path(path_16S, "filtered", paste0(sample_names, "_filt_F.fastq.gz"))
filtRs <- file.path(path_16S, "filtered", paste0(sample_names, "_filt_R.fastq.gz"))

# name the file paths with the corresponding sample names
names(filtFs) <- sample_names
names(filtRs) <- sample_names




filt_out <- filterAndTrim(fnFs_cut, filtFs, fnRs_cut, filtRs,
                     truncLen = c(220, 210), # cut for the forward and reverse files
                     maxN = 0, # DADA2 requires no Ns
                     maxEE = c(1, 1), # reads with higher than maxEE "expected errors" will be discarded
                     truncQ = 2, # Truncate reads at the first instance of a quality score less than or equal to truncQ
                     rm.phix = TRUE, # If TRUE, discard reads that match against the phiX genome (kinda control bacteria)
                     compress = TRUE, #  Whether the output fastq file should be gzip com- pressed.
                     multithread = TRUE) # On Windows set multithread = FALSE
head(filt_out)

# the percent of reads making it through the filter and trim step:
filter_perc <- (colSums(filt_out)[2]/colSums(filt_out)[1] * 100) # 95.7%

```

After filtering out the low quality reads, we have maintained about `r round(filter_perc, 1)` of the original reads.

<br/>
<br/>

### Check the filtering

Viewing the quality of the same 2 of the forward samples post filtering and trimming
```{r forward quality plots post filter trim, fig.height = 3, fig.width = 6, fig.align = "center"}

## plot the filtered forward samples
plotQualityProfile(filtFs[1:2])

```

```{r save forward quality plots post filter trim, eval=FALSE, include=FALSE}

## save the filtered forward quality plots
png(file = "Figures/Exploratory/Forward_filt_qualityPlots.png", width = 30, height = 23, res = 1200, unit = "cm")
plotQualityProfile(filtFs)
dev.off()

```

Viewing the quality of the same 2 of the reverse samples post filtering and trimming
```{r reverse quality plots post filter trim, fig.height = 3, fig.width = 6, fig.align = "center"}

## plot the filtered reverse samples
plotQualityProfile(filtRs[1:2])

```

```{r save reverse quality plots post filter trim, eval=FALSE, include=FALSE}

## save the filtered reverse quality plots
png(file = "Figures/Exploratory/Reverse_filt_qualityPlots.png", width = 30, height = 23, res = 1200, unit = "cm")
plotQualityProfile(filtRs)
dev.off()

```

<br/>
<br/>


## DADA2 sample processing {.tabset}

### Error Rates

```{r learn errors and save, eval=FALSE, include=FALSE}

### Learning the error rates takes a few minutes so I am saving it as an R object to call in line. If things are modified upstream, this needs to be rerun.

errF <- learnErrors(filtFs, multithread = TRUE)
errR <- learnErrors(filtRs, multithread = TRUE)

# visualize errors
errF_plot <- plotErrors(errF, nominalQ = TRUE)
errR_plot <- plotErrors(errR, nominalQ = TRUE)


## Save the error rates
save(errF, errR, errF_plot, errR_plot, file = "Data/16s_data/dada_errors.Rdata")

```

```{r load and viz errors, fig.height = 5, fig.width = 7, fig.align = "center"}

load("Data/16s_data/dada_errors.Rdata")

errF_plot

```

The error rates for each possible transition (A→C, A→G, …) are shown. Points are the observed error rates for each consensus quality score. The black line shows the estimated error rates after convergence of the machine-learning algorithm. The red line shows the error rates expected under the nominal definition of the Q-score. We want the estimated error rates (black line) to be a good fit to the observed rates (points), and the error rates to drop with increased quality.

<br/>
<br/>


### Sample Inference

We are now ready to apply [the core sample inference algorithm](https://www.nature.com/articles/nmeth.3869#methods) to the filtered and trimmed sequence data.

<br/>

**Forward sample inference**
```{r forward sample inference}

# Core sample inference of forward samples
dadaFs <- dada(filtFs, err = errF, multithread = TRUE)

```

Inspecting the returned dada-class object for the first forward sample:
```{r view dada class object}

# Inspecting the returned dada-class object:
dadaFs[[1]]

```

The DADA2 algorithm inferred 144 true sequence variants from the 9515 unique sequences in the first sample. There is much more to the dada-class return object than this (see help(`"dada-class"`) for some info), including multiple diagnostics about the quality of each denoised sequence variant, but that is beyond the scope of an introductory tutorial.

<br/>

**Reverse sample inference**
```{r reverse sample inference}

# Core sample inference of reverse samples
dadaRs <- dada(filtRs, err = errR, multithread = TRUE)

```

<br/>
<br/>


### Merge paired reads

We now merge the forward and reverse reads together to obtain the full denoised sequences. Merging is performed by aligning the denoised forward reads with the reverse-complement of the corresponding denoised reverse reads, and then constructing the merged “contig” sequences. By default, merged sequences are only output if the forward and reverse reads overlap by at least 12 bases, and are identical to each other in the overlap region (but these conditions can be changed via function arguments).

```{r merge paired reads}

mergers <- mergePairs(dadaF = dadaFs, # dada-class object(s) generated by denoising the forward reads.
                      derepF = filtFs, # derep-class object(s) used as input to the the dada function when denoising (for)
                      dadaR = dadaRs, # dada-class object(s) generated by denoising the reverse reads.
                      derepR = filtRs, # derep-class object(s) used as input to the the dada function when denoising (rev)
                      verbose = TRUE) # summary of the function results are printed to standard output (verbose = TRUE)

# Inspect the merger data.frame from the first sample
#head(mergers[[1]])

```

The mergers object is a list of data.frames from each sample. Each data.frame contains the merged sequence, its abundance, and the indices of the forward and reverse sequence variants that were merged. Paired reads that did not exactly overlap were removed by mergePairs, further reducing spurious output.

<br/>
<br/>


### Construct sequence table

We can now construct an amplicon sequence variant table (ASV) table, a higher-resolution version of the OTU table produced by traditional methods.

<br/>

```{r make ASV table}

seqtab <- makeSequenceTable(mergers)
#dim(seqtab) # 38 samples, 3546 sequence variants

# Inspect distribution of read lengths
table(nchar(getSequences(seqtab)))
hist(nchar(getSequences(seqtab)))

```

The sequence table is a matrix with rows corresponding to (and named by) the samples, and columns corresponding to (and named by) the sequence variants. This table contains `r dim(seqtab)[2]` ASVs.

<br/>

After viewing the distribution of read lengths, it looks like we have some that fall outside the expected range (244 - 264) so we will go ahead and remove these non target length sequences.

```{r remove nontarget sequences}

# Remove any ASVs that are considerably off target length
seqtab_trimmed <- seqtab[,nchar(colnames(seqtab)) %in% seq(244,264)]
table(nchar(getSequences(seqtab_trimmed)))

```

This updated table now contains `r dim(seqtab_trimmed)[2]` ASVs.

<br/>
<br/>


### Remove chimeras

The core dada method corrects substitution and indel errors, but chimeras remain. Fortunately, the accuracy of sequence variants after denoising makes identifying chimeric ASVs simpler than when dealing with fuzzy OTUs. Chimeric sequences are identified if they can be exactly reconstructed by combining a left-segment and a right-segment from two more abundant “parent” sequences.

```{r find chimeras}

seqtab_nochim <- removeBimeraDenovo(seqtab_trimmed, method = "consensus", multithread = TRUE, verbose = TRUE)
#dim(seqtab_nochim)
rownames(seqtab_nochim) <- gsub("_filt_F.fastq.gz", "", rownames(seqtab_nochim))

perc_nochim <- (sum(seqtab_nochim)/sum(seqtab) * 100) # percent non chimera sequences kept


## Save the chimera-free ASV table to load in downstream analyses
save(seqtab_nochim, file = "Data/16s_data/seqtab_nochim.Rdata")

```

A total of `r dim(seqtab_trimmed)[2] - dim(seqtab_nochim)[2]` bimeras were identified from the `r dim(seqtab_nochim)[2]` input sequences, thus retaining `r round(perc_nochim, 1)`% of sequences.

<br/>
<br/>


### Track reads through the pipeline

As a final check of our progress, we can look at the number of reads that made it through each step in the pipeline:

```{r track reads through pipeline}

track_reads <- cbind(meta[1], paste(meta$Genotype, meta$Frag, sep = " "), meta[c(3,5)], filt_out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab_nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)

colnames(track_reads) <- c("Sample ID", "Sample", "Genotype", "Treatment", "Input", "Filtered", "Denoised Forward", "Denoised Reverse", "Merged", "Nonchimera")
rownames(track_reads) <- sample_names

```

```{r kable of reads through pipeline}

kable(track_reads, row.names = FALSE) %>% 
  #kable_minimal() %>% 
  kable_classic_2() %>% 
  kable_styling(font_size = 14, full_width = FALSE) %>% 
  column_spec(1, bold = TRUE) %>% 
  column_spec(2, border_right = TRUE)

write.csv(track_reads, "Tables/Track_Reads.csv", row.names = FALSE)

```

<br/>
<br/>


## Assign taxonomy

It is common at this point, especially in 16S/18S/ITS amplicon sequencing, to assign taxonomy to the sequence variants. The DADA2 package provides a native implementation of the naive Bayesian classifier method for this purpose. The `assignTaxonomy` function takes as input a set of sequences to be classified and a training set of reference sequences with known taxonomy, and outputs taxonomic assignments with at least `minBoot` bootstrap confidence.

The dada2 package GitHub maintains the most updated versions of the [Silva databases.](https://benjjneb.github.io/dada2/training.html), but I downloaded the databases from the associated [Zenodo](https://zenodo.org/record/4587955#.YuBdCS-cbOQ). The versions in this GitHub repository, used here, were last updated on 26 July 2022.

```{r SILVA path, eval=FALSE, include=FALSE}

## going to move these out of this repo because they are too big:
# SCC path to SILVA files: /projectnb/davieslab/bove/SILVA_files
# local path to SILVA files: /Users/colleen/Dropbox/BU/DaviesLab/ACER_microplastics/SILVA/

if(length(grep("Dropbox", wd)) > 0) {
  silva_path <- "/Users/colleen/Dropbox/BU/DaviesLab/ACER_microplastics/SILVA/silva_nr99_v138.1_train_set.fa.gz" 
} else {
  silva_path <- "/projectnb/davieslab/bove/SILVA_files/silva_nr99_v138.1_train_set.fa.gz" 
}

taxa <- assignTaxonomy(seqtab_nochim, silva_path, multithread=TRUE)



# Extensions: The dada2 package also implements a method to make species level assignments based on exact matching between
# ASVs and sequenced reference strains. Recent analysis suggests that exact matching (or 100% identity) is the only
# appropriate way to assign species to 16S gene fragments. Currently, species-assignment training fastas are available for
# the Silva and RDP 16S databases. To follow the optional species addition step, download the
# silva_species_assignment_v138.1.fa.gz file, and place it in the directory with the fastq files.

if(length(grep("Dropbox", wd)) > 0) {
  silva_sp_path <- "/Users/colleen/Dropbox/BU/DaviesLab/ACER_microplastics/SILVA/silva_species_assignment_v138.1.fa.gz" 
} else {
  silva_sp_path <- "/projectnb/davieslab/bove/SILVA_files/silva_species_assignment_v138.1.fa.gz" 
}

taxa_sp <- addSpecies(taxa, silva_sp_path)



## Save objects to save time running (but will need to rerun if making upstream adjustments)
save(taxa, taxa_sp, file = "Data/16s_data/taxa_assign.Rdata")

```

Let’s inspect the taxonomic assignments:

```{r load phylo taxa objects and view}

load("Data/16s_data/taxa_assign.Rdata")

taxa_print <- taxa_sp # Removing sequence rownames for display only
rownames(taxa_print) <- NULL
head(taxa_print)

```

```{r create ASV table using phyloseq}

# Export sequence table with genus and species assignments as phyloseq objects
phylo <- phyloseq(otu_table(seqtab_nochim, taxa_are_rows = FALSE),
                  sample_data(meta),
                  tax_table(taxa))
phylo_sp <- phyloseq(otu_table(seqtab_nochim, taxa_are_rows = FALSE),
                     sample_data(meta),
                     tax_table(taxa_sp))

# originally, sequences were the taxa names
seqs_ps <- taxa_names(phylo_sp)

# add a sequence column to matrix
taxa2 <- cbind(tax_table(phylo_sp), seqs_ps)
rownames(taxa2) <- paste0("ASV", seq(ntaxa(phylo_sp))) # rename these rows

# change taxa names to ASVs in the phyloseq object
taxa_names(phylo_sp) <- paste0("ASV", seq(ntaxa(phylo_sp)))


# save a file of the taxa table with ASVs and sequences
taxtab_seqs <- cbind(data.frame(tax_table(phylo_sp)), seqs_ps)
write.csv(taxtab_seqs, "Data/16s_data/taxatable_withsequences.csv")



## Save as RDS objects
save(phylo, phylo_sp, taxa2, file = "Data/16s_data/phylo_objs.Rdata") # save both with and without species level and ASV labeling

```

Great! We can now save this and hand it off to Phyloseq for further analyses.

<br/>
<br/>


## Remove contaminations {.tabset}

### Remove mitochondria, chloroplasts, and non-bacteria

```{r load phylo objects}

## Load the phyloseq objects created above
load(file = "Data/16s_data/phylo_objs.Rdata")

```

```{r remove contam taxa}

# remove all mitochondria from family  
ps_nomito <- subset_taxa(phylo_sp, (Family != "Mitochondria") | is.na(Family))

# remove all chloroplast from order
ps_nochlor <- subset_taxa(ps_nomito, (Order != "Chloroplast") | is.na(Order))

# remove all non-bacteria
ps_clean <- subset_taxa(ps_nochlor, (Kingdom == "Bacteria"))
ps_clean

## total number of contam above removed
contam_tot <- dim(phylo_sp@otu_table)[[2]] - dim(ps_clean@otu_table)[[2]]

```

Removal of mitochondira, chloroplasts, and non-bacteria taxa reduced the total number of taxa from `r dim(phylo_sp@otu_table)[[2]]` to `r dim(ps_clean@otu_table)[[2]]` (`r contam_tot` total). 

<br/>
<br/>


### Remove neg control contamination

```{r library size, fig.height = 4, fig.width = 6, fig.align = "center"}

## Visualize library sizes per sample
df <- data.frame(sample_data(ps_clean)) # make sample_data a dataframe
df$LibrarySize <- sample_sums(ps_clean) # add reads per sample
df <- df[order(df$LibrarySize),] # reorder df from lowest to highest library size
df$Index <- seq(nrow(df)) # add index for plotting

# plot library size by treatment
ggplot(data = df, aes(x = Index, y = LibrarySize, color = Treatment)) + 
  geom_point() +
  ggtitle("Library size by treatment of all samples")

## identify contaminants based on neg controls
sample_data(ps_clean)$is.neg <- sample_data(ps_clean)$Treatment == "blank_control" # identify neg controls & add to sample data
contamdf_freq <- isContaminant(ps_clean, neg = "is.neg", threshold = 0.5) # The frequency of each sequence (or OTU) in the input feature table as a function of the concentration of amplified DNA in each sample is used to identify contaminant sequences.

neg_contam <- table(contamdf_freq$contaminant)
#head(which(contamdf_freq$contaminant)) # which ASVs are being identified as contaminants 

```

Just `r neg_contam[[2]]` out of the `r nrow(contamdf_freq)` ASVs were classified as contaminants. 

<br/>

```{r neg control contam removal, fig.height = 4, fig.width = 6, fig.align = "center"}

# Make phyloseq object of presence-absence in negative controls and true samples
ps_pa <- transform_sample_counts(ps_clean, function(abund) 1 * (abund > 0)) # transforms the sample counts of a taxa abundance matrix
ps_pa_neg <- prune_samples(sample_data(ps_pa)$Treatment == "blank_control", ps_pa) # filters samples for controls
ps_pa_pos <- prune_samples(sample_data(ps_pa)$Treatment != "blank_control", ps_pa) # filters to remove controls

# Make dataframe of prevalence in positive and negative samples
df_pa <- data.frame(pa_pos = taxa_sums(ps_pa_pos),
                    pa_neg = taxa_sums(ps_pa_neg),
                    contaminant = contamdf_freq$contaminant)

# plot prevalence of neg controls against true samples
ggplot(data = df_pa, aes(x = pa_neg, y = pa_pos, color = contaminant)) +
  geom_point() +
  xlab("Prevalence (Negative Controls)") +
  ylab("Prevalence (True Samples)")

# remove contam taxa from ps_clean:
ps_clean1 <- prune_taxa(!contamdf_freq$contaminant, ps_clean)

# also remove negative controls, don't need them anymore I think
ps_cleaner <- subset_samples(ps_clean1, (Treatment != "blank_control"))

ps_cleaner # 1607 taxa left, 19 samples      3272 taxa left, 36 samples

```

<br/>
<br/>


### Blast NCBI

**I have not rerun this portion since only running the pipeline with the 19 GE samples!**

```{r save the sequences to fasta for blast, eval=FALSE, include=FALSE}

## make output fasta file 
ids <- paste0("ASV", seq(1, length(colnames(seqtab_nochim))))
uniquesToFasta(seqtab_nochim, "Data/16s_data/acer_cleaned_16s.fasta", ids = ids, mode = "w", width = 20000)

```

```{r blast, eval=FALSE, include=TRUE}

######## Blast ASVs against NCBI
### This portion was run on the SCC on XXXX and the script can also be found on 'acer_SCC_pipeline_28Jun22.sh' script


##------------------------------
#### Blasting ASVs against NCBI
## this portion is referenced in the Rmarkdown (microplastics_16S_dada2.Rmd; 'Blast NCBI' section)
## used 'acer_cleaned_16s.fasta' made in the Rmarkdown file
##------------------------------

#  ## load blast
#  module load blast+
#  
#  ## write job script for blasting the fasta
#  nano blast_taxa.sh
#  
#  # ---
#  #!/bin/bash -l
#  #$ -l h_rt=24:00:00
#  #$ -cwd # start job in submission directory
#  #$ -N blastIT # job name, anything you want
#  #$ -M colleenbove@gmail.com
#  #$ -m be
#  
#  module load blast+
#  
#  blastn -query acer_cleaned_16s.fasta -db nt -outfmt "6 std staxids sskingdoms" -evalue 1e-5 -max_target_seqs 5 -out acer_taxids.out -remote
#  # ---
#  
#  ## submit job
#  qsub -pe omp 28 blast_taxa.sh
#  # takes a very long time 
#  
#  # move file to github repo
#  scp -r bovec@scc1.bu.edu:/projectnb/davieslab/bove/acer_MP/taxa_scripts/acer_taxids.out /Users/colleen/Dropbox/Git/acer_microplastics/Data/16s_data
#  
#  
#  ##now getting taxonomy info:
#  
#  # #download/install taxonkit things, more instructions here:
#  # #https://bioinf.shenwei.me/taxonkit/usage/
#  
#  cd /projectnb/davieslab/bove/taxa
#  wget -c ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz 
#  tar -zxvf taxdump.tar.gz
#  
#  module load miniconda
#  conda create --name taxonkit 
#  conda install -c bioconda taxonkit -p /projectnb/davieslab/bovec/.conda/envs/taxonkit
#  
#  cd /projectnb/davieslab/bove/taxa/
#  cp *.dmp ~/.taxonkit
#  conda activate taxonkit
#  # #command taxonkit should work now
#  
#  ## extracting taxa ids from blast output for taxonkit:
#  cd /projectnb/davieslab/bove/acer_MP/taxa_scripts
#  module load miniconda
#  conda activate taxonkit
#  
#  
#  awk -F " " '{print $13}' acer_taxids.out > ids
#  taxonkit lineage ids > ids_tax
#  cut -f1 acer_taxids.out > ids_seq; paste ids_seq ids_tax > ids_seq_tax
#  grep "Eukaryota" ids_seq_tax | cut -f1 | sort | uniq > euk_contam_asvs.csv
#  
#  
#  # move file to github repo (Data/16s_data/euk_contam_asvs.csv)
#  scp -r bovec@scc1.bu.edu:/projectnb/davieslab/bove/acer_MP/taxa_scripts/euk_contam_asvs.csv /Users/colleen/Dropbox/Git/acer_microplastics/Data/16s_data

```

```{r remove eukaryote contamination}

## read in euk_contam_asvs.csv to remove from ps_cleaner
# should be 158 to remove
euks <- read.csv("Data/16s_data/euk_contam_asvs.csv", header = FALSE)
euks_names <- euks$V1 # make list from sequence names that are eukaryotes

alltaxa <- taxa_names(ps_cleaner) 
#length(alltaxa) # 3272 total 
keepers <- alltaxa[!(alltaxa %in% euks_names)] 
#length(keepers) # 3231, so that means only 41 euks got through above
phylo_cleanest <- prune_taxa(keepers, ps_cleaner) 
# 3231 ASVs, 36 (1538 ASVs, 19) samples in phylo_cleanest 

### remove sample A5
#phylo_cleanest <- subset_samples(phylo_cleanest, sampleID != "A5")
#phylo_cleanest # 3231 taxa and 35 samples

seqtab_cleanest <- data.frame(otu_table(phylo_cleanest))
samdf_cleanest <- data.frame(phylo_cleanest@sam_data)

## Save as RDS objects
save(phylo_cleanest, seqtab_cleanest, samdf_cleanest, file = "Data/16s_data/phylo_clean.Rdata") # save both seqtab and phylo clean objects

```

```{r pre rare and trim count info}

## calculate mean and SD counts across samples
preRare_count <- rowSums(otu_table(phylo_cleanest))
mean_preRare <- mean(preRare_count) # mean counts
sd_preRare <- sd(preRare_count) # standard deviation 



# find min and max sample IDs
otu_tab <- data.frame(otu_table(phylo_cleanest), sum = rowSums(otu_table(phylo_cleanest)))

min_sample <- rownames(filter(otu_tab, sum == min(preRare_count)))
max_sample <- rownames(filter(otu_tab, sum == max(preRare_count)))

```

Looks good! We have now cleaned up the sample data to remove contamination from non target organisms and those from the negative controls. The cleaned samples averaged `r round(mean_preRare, 0)` counts (+/- `r round(sd_preRare, 0)` SD).

<br/>
<br/>


## Rarefy {.tabset}

### Rarefy cleaned data

Sample A5 is weirdly high so I am going to remove it from here and through downstream analyses.

```{r rarefaction plots, fig.align="center"}

load(file = "Data/16s_data/phylo_clean.Rdata")

## 
S <- specnumber(seqtab_cleanest) # observed number of species
raremax <- min(rowSums(seqtab_cleanest)) # set the minimum num of ASVs per sample as sample value
Srar <- rarefy(seqtab_cleanest, raremax) # gives the expected species richness in random subsamples
seqtab_rare <- rrarefy(seqtab_cleanest, raremax) # generates one randomly rarefied community data frame or vector of given sample size

# plot of observed v rarefied (expected) # of species
plot(S, Srar, xlab = "Observed No. of Species", ylab = "Rarefied No. of Species")
abline(0, 1)

# plot the rarefaction curve with the 17668 sample line
rarecurve(seqtab_cleanest, step = 20, sample = raremax, col = "blue", cex = 0.6) 

```

```{r rarefied phylo object}

## subset the taxa2 to only have cleaned ASVs
taxa_clean <- subset(taxa2, rownames(taxa2) %in% colnames(seqtab_rare))

# phyloseq object but rarefied
phylo_rare <- phyloseq(otu_table(seqtab_rare, taxa_are_rows = FALSE), 
               sample_data(samdf_cleanest), 
               tax_table(taxa_clean))
phylo_rare # 1538 taxa in 19 sample     3231 taxa in 35 samples

# removing missing taxa - lost after rarefying
phylo_rare <- prune_taxa(taxa_sums(phylo_rare) > 0, phylo_rare)
phylo_rare # 3166 in 36 samples after pruning     (1503 in 19 samples)

seqtab_rare <- data.frame(otu_table(phylo_rare))


## Save the rarefied objects
save(phylo_rare, seqtab_rare, samdf_cleanest, taxa_clean, file = "Data/16s_data/phylo_rarefy.Rdata")

```

<br/>
<br/>


### Trim underrepresented OUTs

```{r trim low OUTs}

load(file = "Data/16s_data/phylo_clean.Rdata")

#formatting the table for mcmc.otu - requires one first column that's 1 through whatever
#& has "X" as column name
nums <- 1:nrow(seqtab_cleanest) 
samples <- rownames(seqtab_cleanest)

int <- cbind(sample = 0, seqtab_cleanest)
seq_formcmc <- cbind(X = 0, int)

seq_formcmc$X <- nums
seq_formcmc$sample <- samples

seq_trim_allinfo <- purgeOutliers(seq_formcmc, count.columns = 3:3274, sampleZcut = -2.5, otu.cut = 0.0001, zero.cut = 0.02)
# no bad samples identified
# 260 ASVs in 35 samples pass filters (416 ASVs in 19 samples)

#remove sample info
seq_trim <- seq_trim_allinfo[,3:262] 


#remake phyloseq objects
phylo_trim <- phyloseq(otu_table(seq_trim, taxa_are_rows=FALSE), 
                         sample_data(samdf_cleanest), 
                         tax_table(taxa_clean))
phylo_trim # 260 asvs


## Save the trimmed data
save(phylo_trim, seq_trim, samdf_cleanest, taxa_clean, file = "Data/16s_data/phylo_trim.Rdata")

```

<br/>
<br/>


### Rarefy trimmed data

```{r trimmed rarefaction}

load(file = "Data/16s_data/phylo_trim.Rdata")

## Rerunning rarefaction after trimming underrepresented otus and bad samples (is any -- I don't have these)

## pull trimmes OUT table and sample data
seqtab_trim <- data.frame(phylo_trim@otu_table)
samdf_trim <- data.frame(phylo_trim@sam_data) # we didn't drop any samples so this is still the same

# plot rarefation curve
rarecurve(seqtab_trim, step = 20, label = FALSE) 

S_trm <- specnumber(seqtab_trim) # observed number of species
raremax_trim <- min(rowSums(seqtab_trim)) # set the minimum num of ASVs per sample as sample value
Srar_trm <- rarefy(seqtab_trim, raremax_trim) # gives the expected species richness in random subsamples
seqtab_trm_rare <- rrarefy(seqtab_trim, raremax_trim) # generates one randomly rarefied community data frame or vector of given sample size

# plot of observed v rarefied # of species
plot(S_trm, Srar_trm, xlab = "Observed No. of Species (trimmed)", ylab = "Rarefied No. of Species")
abline(0, 1)

# plot the rarefaction curve with the 7710 sample line
rarecurve(seqtab_trim, step = 20, sample = raremax_trim, col = "blue", cex = 0.6, label = TRUE) 

## remove samples that don't meet the rare cutoff
total <- rowSums(seqtab_trim) # sum row counts per sample
subset(total, total < raremax_trim) # identify samples that don't meet count cutoff 
row_rm<- c() # low sample names here
seqtab_less <- seqtab_trim[!(row.names(seqtab_trim) %in% row_rm),] # filter to remove the low samples

seqtab_trim_rare <- rrarefy(seqtab_less, sample = raremax_trim) # generate one randomly rarefied community data frame or vector of given sample size

# plot the rarefaction curve with the 7710 sample line
rarecurve(seqtab_trim_rare, step = 20, sample = raremax_trim, col = "blue", cex = 0.6, label = TRUE) 

#phyloseq object but rarefied & trimmed
phylo_trim_rare <- phyloseq(otu_table(seqtab_trim_rare, taxa_are_rows=FALSE), 
                    sample_data(samdf_trim), 
                    tax_table(taxa_clean))
phylo_trim_rare # 260 taxa remain


## Save the trimmed and rarefied data
save(phylo_trim_rare, seqtab_trim_rare, samdf_trim, taxa_clean, file = "Data/16s_data/phylo_trim_rare.Rdata")

```

<br/>
<br/>


## Microbiome diversity analyses {.tabset}

[Notes from phyloseq author](https://rdrr.io/bioc/phyloseq/man/estimate_richness.html)
Visualize alpha-diversity - Should be done on raw, untrimmed dataset

<br/>

### Relative abundance across samples

```{r barplot phylum of all samples}

load(file = "Data/16s_data/phylo_clean.Rdata")

## Phyla of all trimmed and rarefied ASVs
phylo_trim_rare_rel <- transform_sample_counts(phylo_trim_rare, function(x) x / sum(x))
phylo_trim_rare_rel_df <- data.frame(tax_table(phylo_trim_rare_rel))

trim_rare_rel_phyla <- plot_bar2(phylo_trim_rare_rel, x = "Genotype", fill="Phylum", colour="Phylum")+
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "bottom", ) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(21)) +
  scale_colour_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(21)) +
  ylab("Relative abundance") +
  facet_wrap2( ~ Treatment, scales = "free_y", ncol = 4,  
    strip = strip_themed(background_x = list(element_rect(fill = opacity(trt_col, 0.3)[[1]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[2]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[3]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[4]])) )) +
  guides(color = guide_legend(nrow = 3, byrow = FALSE, keyheight = 0.1, default.unit = "cm"), fill = guide_legend(nrow = 3, byrow = FALSE, keyheight = 0.1, default.unit = "cm")) +
  ggtitle("Rarefied total ASVs (relative abundance)")
ggplotly(trim_rare_rel_phyla)

```

Samples appear to be dominated by taxa within the phylum Proteobacteria. Next, I have visualized the diversity of bacteria within Proteobacteria only.

```{r barplot proto order of all samples}

## Selecting just Phylum Proteobacteria 
phylo_proteo <- subset_taxa(phylo_trim_rare, Phylum %in% "Proteobacteria")
phylo_proteo_rel <- transform_sample_counts(phylo_proteo, function(x) x / sum(x))

proteo_plot <- plot_bar2(phylo_proteo_rel, x = "Genotype", fill = "Order", colour = "Order")+
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.key.size = unit(0.3, 'cm')) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(24)) +
  scale_colour_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(24)) +
  ylab("Relative abundance") +
  facet_wrap2( ~ Treatment, scales = "free_y",  
    strip = strip_themed(background_x = list(element_rect(fill = opacity(trt_col, 0.3)[[1]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[2]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[3]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[4]])) )) +
  guides(color = guide_legend(ncol = 1), fill = guide_legend(ncol = 1)) +
  ggtitle("Proteobacteria ASVs (relative abundance)")
ggplotly(proteo_plot)

```

Again, there is a clear dominance across samples by a single order (Rickettsiales), regardless of experimental treatment. I have selected just this order to view the different ASVs that make up this order.

```{r barplot Rickettsiales ASVs}

## Selecting just Order Rickettsiales  
phylo_rick <- subset_taxa(phylo_proteo, Order %in% "Rickettsiales")
phylo_rick_df <- data.frame(tax_table(phylo_rick)[,-7])
phylo_rick_rel <- transform_sample_counts(phylo_rick, function(x) x / sum(x))


rick_plot <- plot_bar2(phylo_rick_rel, x = "Genotype", fill = "seqs_ps", colour = "seqs_ps")+
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(panel.grid = element_blank()) +
  scale_fill_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(4), labels = rownames(phylo_rick_df)) +
  scale_colour_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(4), labels = rownames(phylo_rick_df)) +
  ylab("Relative abundance") +
  facet_wrap2( ~ Treatment, scales = "free_y",  
    strip = strip_themed(background_x = list(element_rect(fill = opacity(trt_col, 0.3)[[1]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[2]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[3]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[4]])) )) +
  ggtitle("Rickettsiales ASVs (relative abundance)")
rick_plot
#ggplotly(rick_plot)

```

<br/>
<br/>


### Alpha diversity

```{r read in sample data}

samdf <- read.csv("Data/Acerv_MP_Metadata.csv") %>% 
  separate(Genotype, c("Genotype", "Frag"), sep = "(?=[A-Z])") %>% 
  droplevels()
row.names(samdf) <- samdf$sampleID

```

```{r read in phyloseq objects, include=FALSE}

### Untrimmed versions
## Load the cleaned phylo objects
load(file = "Data/16s_data/phylo_clean.Rdata")
phylo_cleanest # 3230 cleaned across all 36 samples

## Load the rarefied phylo objects
load(file = "Data/16s_data/phylo_rarefy.Rdata") # <-- this file also loads the 'taxa2' tax table
phylo_rare # 3115 rarefied across all 36 samples


### Trimmed versions
## Load the trimmed phylo objects
load(file = "Data/16s_data/phylo_trim.Rdata")
phylo_trim # 257 trimmed across all 36 samples

## Load the trimmed and rarefied phylo objects
load(file = "Data/16s_data/phylo_trim_rare.Rdata")
phylo_trim_rare # 257 rarefied and trimmed across all 36 samples

```

```{r generate div metrics}

alpha_df <- data.frame(estimate_richness(phylo_rare, split = TRUE, measures=c("Shannon", "InvSimpson", "Observed"))) # calculate shannon diversity, simpson, and observed species richness

alpha_df$sampleID <- rownames(alpha_df)
alpha_df_div <- merge(samdf, alpha_df, by = "sampleID") #add sample data
alpha_df_div <- alpha_df_div %>% droplevels() # need to drop the blanks
  

# shannon diversity divided by species richness (Evenness)
alpha_df_div$Evenness <- alpha_df_div$Shannon / (log(alpha_df_div$Observed))

```

<br/>


#### Simpson diversity

```{r simpson diversity by treatment}

simp_plot <- ggplot(alpha_df_div, aes(x = Treatment, y = InvSimpson, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Inv. Simpson index") +
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

```{r simpson stats, include=FALSE}

## Simpson diversity linear mixed-effects model with a random slope of genotype
simp_lm <- lmer((1 / InvSimpson) ~ Treatment + (1|Genotype), data = alpha_df_div)
# need to transform data (inverse) to meet model assumptions


# checking the model
check_normality(simp_lm) # residuals appear normal
check_heteroscedasticity(simp_lm) # error variance is homoscedastic
#check_model(simp_lm) # overview: looks alright

## model significance and summary
simp_pval <- Anova(simp_lm)
#summary(simp_lm)

```

```{r add stats to simpson plot, fig.align = 'center', fig.height = 4, fig.width = 7}

## Add the stats to the plot
simp_plot_pval <- substitute(italic(P)==p, list(p = format(simp_pval[[1,3]], digits = 2)))

simp_stat_plot <- simp_plot +
  annotate("text", x = 1, y = 78, label = deparse(simp_plot_pval), parse = TRUE, size = 4) +
  theme(axis.title = element_blank()) +
  ggtitle("  Inv. Simpson index")
simp_stat_plot

```

<br/>


#### Shannon diversity

```{r shannon diversity by treatment}

shan_plot <- ggplot(alpha_df_div, aes(x = Treatment, y = Shannon, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Shannon index")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

```{r shannon stats, include=FALSE}

## Shannon diversity linear mixed-effects model with a random slope of genotype
shan_lm <- lmer(log(Shannon) ~ Treatment + (1|Genotype), data = alpha_df_div)
# need to transform data (log) to meet model assumptions


## checking the model
check_normality(shan_lm) # residuals appear normal
check_heteroscedasticity(shan_lm) # error variance is homoscedastic
#check_model(shan_lm) # overview: looks alright

## view model significance
shan_pval <- Anova(shan_lm)
#summary(shan_lm)

```

```{r add stats to shannon plot, fig.align = 'center', fig.height = 4, fig.width = 7}

## Add the stats to the plot
shan_plot_pval <- substitute(italic(P)==p, list(p = format(shan_pval[[1,3]], digits = 2)))

shan_stat_plot <- shan_plot +
  annotate("text", x = 1, y = 5.6, label = deparse(shan_plot_pval), parse = TRUE, size = 4) +
  theme(axis.title = element_blank()) +
  ggtitle("  Shannon index")
shan_stat_plot

```

<br/>


#### Species richness

```{r richness by treatment}

rich_plot <- ggplot(alpha_df_div, aes(x = Treatment, y = Observed, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("ASV richness")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

```{r richness stats, include=FALSE}

## Species richness linear mixed-effects model with a random slope of genotype
rich_lm <- lmer((1 / Observed) ~ Treatment + (1|Genotype), data = alpha_df_div)
# need to transform data (inverse) to meet model assumptions


## checking the model
check_normality(rich_lm) # residuals not norma;
check_heteroscedasticity(rich_lm) # error variance is NOT homoscedastic, but proceeding
#check_model(rich_lm) # overview: looks okay

## view model significance
rich_pval <- Anova(rich_lm)
#summary(rich_lm)

```

```{r add stats to richness plot, fig.align = 'center', fig.height = 4, fig.width = 7}

## Add the stats to the plot
rich_plot_pval <- substitute(italic(P)==p, list(p = format(rich_pval[[1,3]], digits = 2)))

rich_stat_plot <- rich_plot +
  annotate("text", x = 1, y = 720, label = deparse(rich_plot_pval), parse = TRUE, size = 4) +
  theme(axis.title = element_blank()) +
  ggtitle("  ASV richness")
rich_stat_plot

```

<br/>


#### Evenness

```{r evenness by treatment}

even_plot <- ggplot(alpha_df_div, aes(x = Treatment, y = InvSimpson, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Evenness")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

```{r evenness stats, include=FALSE}

## Evenness linear mixed-effects model with a random slope of genotype
even_lm <- lmer((Evenness) ~ Treatment + (1|Genotype), data = alpha_df_div)

## checking the model
check_normality(even_lm) # residuals not norma;
check_heteroscedasticity(even_lm) # error variance is homoscedastic
#check_model(even_lm) # overview: looks alright

## view model significance
even_pval <- Anova(even_lm)
#summary(even_lm)

```

```{r add stats to evenness plot, fig.align = 'center', fig.height = 4, fig.width = 7}

## Add the stats to the plot
even_plot_pval <- substitute(italic(P)==p, list(p = format(even_pval[[1,3]], digits = 2)))

even_stat_plot <- even_plot +
  annotate("text", x = 1, y = 75, label = deparse(even_plot_pval), parse = TRUE, size = 4) +
  theme(axis.title = element_blank()) +
  ggtitle("  Evenness")
even_stat_plot

```

<br/>


#### All alpha diversity metrics

```{r all alpha diversity, fig.align = 'center', fig.height = 7, fig.width = 8}

ggarrange(simp_stat_plot, shan_stat_plot, rich_stat_plot, even_stat_plot, common.legend = TRUE, labels = "AUTO")

```

<br/>
<br/>


### Beta diversity

```{r PCoA with Koty edits, fig.height = 5, fig.width = 10}

## Ordination of all taxa
#rel abun
pseq_rel_ord <- plot_ordination(phylo_trim_rare_rel, ordinate(phylo_trim_rare_rel,"PCoA", "bray"), color = "Treatment", shape = "Genotype", justDF = TRUE) 
eigvec_rel <- ordinate(phylo_trim_rare_rel,"PCoA", "bray")$values["Eigenvalues"]
percvar_rel <- round(100 * eigvec_rel[1:2,]/sum(eigvec_rel), 1)



### Dispersion stats of core taxa 
seq_all <- data.frame(otu_table(phylo_trim_rare_rel)) # pull the otu table from the core object
dist_all <- vegdist(seq_all) # calculate Bray-Curtis distances between samples
samdf_all <- data.frame(sample_data(phylo_trim_rare_rel)) # pull sample data from the core phyloseq object
bet_all <- betadisper(dist_all, samdf_all$Treatment)

# Run the ANOVA
all_anova <- anova(bet_all)
all_anova
plot(bet_all) # plot the treatments and distances to centroids on the
boxplot(bet_all) # boxplot of the distances to centroid for each treatment

## Dispersion by genotype: not significant 
#dist_all_gen <- betadisper(dist_all, samdf_all$Genotype)
#anova(dist_all_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_all, pairwise = TRUE, permutations = 999) # not significant
#permutest(dist_all_gen, pairwise = TRUE, permutations = 999) # not significant
    

### Multivariate stats (PERMANOVA)
all_adonis <- adonis2(seq_all ~ Treatment + Genotype, data = samdf_all, permutations = 1500)
all_adonis

pcoa_all <- ggplot(data = pseq_rel_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, group = Treatment, shape = Treatment)) +
  geom_point(size = 3, alpha = 0.3) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank(), legend.position = c(0.21, 0.17), legend.key.size = unit(0.4, 'cm')) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(colour = "none",
         fill = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = paste0("Axis 1 (", percvar_rel[1], "%)"),
       y = paste0("Axis 2 (", percvar_rel[2], "%)"))


dis <- data.frame(Treatment = bet_all$group, dist = bet_all$distances, Genotype = samdf_all$Genotype)

dist_plot <- ggplot(dis, aes(x = Treatment, y = dist, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(size = 3, alpha = 0.3, position = position_jitter(width = 0.2)) +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  ylab("Distance to centroid")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "none", axis.text.x = element_blank(), axis.title.x = element_blank())


# combine PCoA with dist from dentroid
ggarrange(pcoa_all, dist_plot, common.legend = TRUE, legend = "bottom")

## save
ggsave("Figures/Exploratory/16S_PCoA_all.png", height = 5, width = 10, dpi = 600)






 top20 <- names(sort(taxa_sums(phylo_trim_rare), decreasing=TRUE))[1:20]
 ps.top20 <- transform_sample_counts(phylo_trim_rare, function(OTU) OTU/sum(OTU))
 ps.top20 <- prune_taxa(top20, ps.top20)
 ps.top20 <- transform_sample_counts(ps.top20, function(OTU) OTU/sum(OTU))
 
 
plot2 <- plot_bar(ps.top20, x = "Genotype", fill="Genus")+
  geom_bar(stat="identity")+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  scale_fill_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(15)) +
  #scale_colour_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(15)) +
  facet_wrap(~Treatment, ncol = 2) +
  ggtitle("Top 20 ASVs across samples")
plot2
# ggplotly(plot2)
 
```

<br/>
<br/>


## Background microbiome {.tabset}

Because samples are all dominated by Aquarickettsia, we wanted to see if the background diversity varied across treatments once we removed those ASVs.  

<br/>

### Relative abundance of non-Aquarickettsia

```{r barplot non aqua classes}

load(file = "Data/16s_data/phylo_clean.Rdata")


## Selecting just Phylum Proteobacteria 
gen_rick <- subset_taxa(phylo_trim_rare, Genus != "MD3-55")
gen_rick_rel <- transform_sample_counts(gen_rick, function(x) x / sum(x))

no_rick_barplot <- plot_bar2(gen_rick_rel, x = "Genotype", fill = "Class", colour = "Class")+
  geom_bar(stat="identity") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.key.size = unit(0.3, 'cm')) +
  scale_fill_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(22)) +
  scale_colour_manual(values = colorRampPalette(brewer.pal(8, "PiYG"))(22)) +
  ylab("Relative abundance") +
  facet_wrap2( ~ Treatment, scales = "free_y", ncol = 4,  
    strip = strip_themed(background_x = list(element_rect(fill = opacity(trt_col, 0.3)[[1]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[2]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[3]]),
                          element_rect(fill = opacity(trt_col, 0.3)[[4]])) )) +
  guides(color = guide_legend(ncol = 1), fill = guide_legend(ncol = 1)) +
  ggtitle("Non Aquarickettsia diversity (relative abundance)")
ggplotly(no_rick_barplot)


## save
ggsave("Figures/Exploratory/16S_noAqua_barplot.png", height = 3.5, width = 10, dpi = 600)

```

<br/>
<br/>


### Alpha diversity

```{r richness without aqua}

## calculate richness
alpha_noAq_df <- data.frame(estimate_richness(gen_rick, split = TRUE, measures=c("Shannon", "InvSimpson", "Observed"))) # calculate shannon diversity, simpson, and observed species richness

alpha_noAq_df$sampleID <- rownames(alpha_noAq_df)
alpha_noAq_df_div <- merge(samdf, alpha_noAq_df, by = "sampleID") #add sample data
alpha_noAq_df_div <- alpha_noAq_df_div %>% droplevels() # need to drop the blanks


# shannon diversity divided by species richness (Evenness)
alpha_noAq_df_div$Evenness <- alpha_noAq_df_div$Shannon / (log(alpha_noAq_df_div$Observed))

```

<br/>
  
  
#### Simpson diversity

```{r simpson diversity by treatment no Aqua}

ggplot(alpha_noAq_df_div, aes(x = Treatment, y = InvSimpson, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Inv. Simpson index") +
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

<br/>
  
  
#### Shannon diversity

```{r shannon diversity by treatment no Aqua}

ggplot(alpha_noAq_df_div, aes(x = Treatment, y = Shannon, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Shannon index")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```


<br/>
  
  
#### Species richness

```{r richness by treatment no Aqua}

ggplot(alpha_noAq_df_div, aes(x = Treatment, y = Observed, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("ASV richness")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

<br/>
  
  
#### Evenness

```{r evenness by treatment no Aqua}

ggplot(alpha_noAq_df_div, aes(x = Treatment, y = InvSimpson, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(alpha = 0.3, position = position_jitter(width = 0.2), size = 4, colour = "black") +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  guides(fill = "none", shape = "none") +
  ylab("Evenness")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.box="vertical")

```

<br/>
<br/>


### Beta Diversity 

```{r PCoA no aqua}

## Ordination of all taxa
#rel abun
pseq_noA_rel_ord <- plot_ordination(gen_rick_rel, ordinate(gen_rick_rel,"PCoA", "bray"), color = "Treatment", shape = "Genotype", justDF = TRUE) 
eigvec_noA_rel <- ordinate(gen_rick_rel, "PCoA", "bray")$values["Eigenvalues"]
percvar_noA_rel <- round(100 * eigvec_noA_rel[1:2,]/sum(eigvec_noA_rel), 1)



### Dispersion stats of core taxa 
seq_noA_all <- data.frame(otu_table(gen_rick_rel)) # pull the otu table from the core object
dist_noA_all <- vegdist(seq_noA_all) # calculate Bray-Curtis distances between samples
samdf_noA_all <- data.frame(sample_data(gen_rick_rel)) # pull sample data from the core phyloseq object
bet_noA_all <- betadisper(dist_noA_all, samdf_noA_all$Treatment)

# Run the ANOVA
all_noA_anova <- anova(bet_noA_all)
all_noA_anova
plot(bet_noA_all) # plot the treatments and distances to centroids on the
boxplot(bet_noA_all) # boxplot of the distances to centroid for each treatment

## Dispersion by genotype: not significant 
#dist_all_gen <- betadisper(dist_all, samdf_all$Genotype)
#anova(dist_all_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_all, pairwise = TRUE, permutations = 999) # not significant
#permutest(dist_all_gen, pairwise = TRUE, permutations = 999) # not significant
    


### Multivariate stats (PERMANOVA)
all_noA_adonis <- adonis2(seq_noA_all ~ Treatment + Genotype, data = samdf_noA_all, permutations = 1500)
all_noA_adonis


## plot
pcoa_noA_plot <- ggplot(data = pseq_noA_rel_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, group = Treatment, shape = Treatment)) +
  geom_point(size = 3, alpha = 0.3) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank(), legend.position = c(0.21, 0.17), legend.key.size = unit(0.4, 'cm')) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(colour = "none",
         fill = guide_legend(override.aes = list(alpha = 1))) +
  labs(x = paste0("Axis 1 (", percvar_rel[1], "%)"),
       y = paste0("Axis 2 (", percvar_rel[2], "%)"))

```

```{r centroid dist no aqua}

dis_noA <- data.frame(Treatment = bet_all$group, dist = bet_all$distances, Genotype = samdf_all$Genotype)

dist_noA_plot <- ggplot(dis_noA, aes(x = Treatment, y = dist, color = Treatment, fill = Treatment, shape = Treatment)) +
  geom_point(size = 3, alpha = 0.3, position = position_jitter(width = 0.2)) +
  geom_boxplot(fill = NA, outlier.colour = NA) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  #scale_shape_manual(values = gen_shape) +
  #scale_shape_manual(values = c(0,1,2,3,4,5,6,7,8,9)) +
  scale_shape_manual(values = c(21, 22, 23, 25)) +
  ylab("Distance to centroid")+
  xlab("Treatment") +
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "none")

```

```{r combine no aqua beta diversity plots}

ggarrange(pcoa_noA_plot, dist_noA_plot, common.legend = TRUE, legend = "bottom") + 
  theme(plot.background = element_rect(fill = "white", colour = NA))

## save
ggsave("Figures/Exploratory/16S_noAqua_beta.png", height = 3.5, width = 7, dpi = 600)

```

<br/>
<br/>


## Core vs. accessory microbiome {.tabset}

### Core

```{r ID core taxa}

## IDing core taxa from the trimmed, rarefied data (in 70% of samples)
pseq_core <- core(phylo_trim_rare, detection = 0, prevalence = 0.99)
pseq_core # 4 core taxa

phylo_core_genus<- tax_glom(pseq_core, "Genus")
phylo_core_genus_rel <- transform_sample_counts(phylo_core_genus, function(x) x / sum(x))
phylo_core_trt <- merge_samples(phylo_core_genus_rel, "Treatment")
phylo_core_trt_rel <- transform_sample_counts(phylo_core_trt, function(x) x / sum(x))

plot_bar2(phylo_core_genus_rel, x = "Genotype", fill="Genus", colour="Genus")+
  geom_bar(stat="identity", colour = "black")+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  scale_fill_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(6)) +
  scale_colour_manual(values = colorRampPalette(rev(brewer.pal(8, "PiYG")))(6)) +
  facet_wrap(~Treatment, ncol = 2) +
  ggtitle("Relative abundance of core taxa (6 ASVs in total)")


#not rel abun
pseq_core_ord <-plot_ordination(pseq_core, ordinate(pseq_core,"PCoA", "bray"), color="Treatment", shape="Genotype", justDF = TRUE) 
eigvec <- ordinate(pseq_core,"PCoA", "bray")$values["Eigenvalues"]
percvar <- round(100 * eigvec[1:2,]/sum(eigvec), 1)

core_plot <- ggplot(data = pseq_core_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, shape = Genotype, group = Treatment)) +
  geom_point(color = "black", size = 4) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  #scale_shape_manual(values = gen_shape) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(fill = "none") +
  labs(x = paste0("Axis 1 (", percvar[1], "%)"),
       y = paste0("Axis 2 (", percvar[2], "%)")) +
  ggtitle("C.   Core taxa")
core_plot


#rel abun
pseq_core_rel <- transform_sample_counts(pseq_core, function(x) x / sum(x))
pseq_core_rel_ord <-plot_ordination(pseq_core_rel, ordinate(pseq_core_rel,"PCoA", "bray"), color="Treatment", shape="Genotype", justDF = TRUE) 
eigvec_rel <- ordinate(pseq_core_rel,"PCoA", "bray")$values["Eigenvalues"]
percvar_rel <- round(100 * eigvec_rel[1:2,]/sum(eigvec_rel), 1)

rel_core_plot <- ggplot(data = pseq_core_rel_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, shape = Genotype, group = Treatment)) +
  geom_point(color = "black", size = 4) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  #scale_shape_manual(values = gen_shape) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(fill = "none") +
  labs(x = paste0("Axis 1 (", percvar_rel[1], "%)"),
       y = paste0("Axis 2 (", percvar_rel[2], "%)")) +
  ggtitle("C.   Core taxa (relative abundance)")
rel_core_plot

```

```{r calculate core abundance, eval=FALSE, include=FALSE}

## calculating core abundances 
core_sqs <- tax_table(pseq_core) # pull taxa table (core, trim, rare)
core_sqs_ids <- rownames(core_sqs) # pull ASV names of the core taxa
ps_rare_trim_rel <- transform_sample_counts(phylo_trim_rare, function(x) x / sum(x)) # calc rel abund of the rare core
seq_rare_rel <- data.frame(otu_table(ps_rare_trim_rel)) # make dataframe of the rel phylo object(above) for otus
tax_core <- tax_table(ps_rare_trim_rel) # pull the taxa table of core
seq_core <- seq_rare_rel %>% select(c(core_sqs_ids)) # select for the core ASVs only
core_rel <- data.frame(mean_abun = colMeans(seq_core))
total_rel <- data.frame(mean_rel = colMeans(seq_rare_rel))
total_rel_ordered <- data.frame(total_rel[order(-total_rel$mean_rel),,drop = FALSE])

```

<br/>

#### Core stats

```{r core stats for rare}

### Dispersion stats of core taxa 
seq_core <- data.frame(otu_table(pseq_core)) # pull the otu table from the core object
dist_core <- vegdist(seq_core) # calculate Bray-Curtis distances between samples
samdf_core <- data.frame(sample_data(pseq_core)) # pull sample data from the core phyloseq object
bet_core <- betadisper(dist_core, samdf_core$Treatment)

# Run the ANOVA
core_anova <- anova(bet_core)
core_anova
plot(bet_core) # plot the treatments and distances to centroids on the
boxplot(bet_core) # boxplot of the distances to centroid for each treatment


## Dispersion by genotype: not significant 
#bet_core_gen <- betadisper(dist_core, samdf_core$Genotype)
#anova(bet_core_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_core, pairwise = TRUE, permutations = 999) # not significant
#permutest(bet_core_gen, pairwise = TRUE, permutations = 999) # not significant
    
### Multivariate stats (PERMANOVA)
core_adonis <- adonis2(seq_core ~ Treatment + Genotype, data = samdf_core, permutations = 1500)
core_adonis

```

```{r core stats for rel abund}

## Dispersion stats f core taxa by relative abundance
seq_core_rel <- data.frame(otu_table(pseq_core_rel))
dist_core_rel <- vegdist(seq_core_rel) # calculate Bray-Curtis distances between samples
bet_core_rel <- betadisper(dist_core_rel, samdf_core$Treatment)

# Run the ANOVA
core_rel_anova <- anova(bet_core_rel)
core_rel_anova
plot(bet_core_rel) # plot the treatments and distances to centroids on the
boxplot(bet_core_rel) # boxplot of the distances to centroid for each treatment

## Dispersion by genotype: not significant 
#bet_rel_core_gen <- betadisper(dist_core_rel, samdf_core$Genotype)
#anova(bet_rel_core_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_core_rel, pairwise = TRUE, permutations = 999) # not significant
#permutest(bet_rel_core_gen, pairwise = TRUE, permutations = 999) # not significant
    
### Multivariate stats (PERMANOVA)
core_rel_adonis <- adonis2(seq_core_rel ~ Treatment + Genotype, data = samdf_core, permutations = 1500)
core_rel_adonis

```

```{r core stat and PCA comparison}

## Add the stats to the core PCA plot (rarefied data)
core_disp_pval <- substitute(italic(P[disp])==p, list(p = format(core_anova[[1,5]], digits = 2)))
core_trt_pval <- substitute(italic(P[treat])==p, list(p = format(core_adonis[[1,5]], digits = 2)))
core_gen_pval <- substitute(italic(P[genotype])==p, list(p = format(core_adonis[[2,5]], digits = 2))) 

core_stat_plot <- core_plot +
  annotate("text", x = 0.6, y = 0.25, label = deparse(core_disp_pval), parse = TRUE, size = 4) +
  annotate("text", x = -0.8, y = -0.24, label = deparse(core_trt_pval), parse = TRUE, size = 4) +
  annotate("text", x = -0.8, y = -0.26, label = deparse(core_gen_pval), parse = TRUE, size = 4) 


## Add the stats to the core PCA plot (rel abund data)
rel_core_disp_pval <- substitute(italic(P[disp])==p, list(p = format(core_rel_anova[[1,5]], digits = 2)))
rel_core_trt_pval <- substitute(italic(P[treat])==p, list(p = format(core_rel_adonis[[1,5]], digits = 2)))
rel_core_gen_pval <- substitute(italic(P[genotype])==p, list(p = format(core_rel_adonis[[2,5]], digits = 2)))

rel_core_stat_plot <- rel_core_plot +
  annotate("text", x = -0.6, y = 0.13, label = deparse(rel_core_disp_pval), parse = TRUE, size = 4) +
  annotate("text", x = 0.7, y = -0.19, label = deparse(rel_core_trt_pval), parse = TRUE, size = 4) +
  annotate("text", x = 0.7, y = -0.21, label = deparse(rel_core_gen_pval), parse = TRUE, size = 4) 

### Combine plots and make decision
ggarrange(core_stat_plot, rel_core_stat_plot, common.legend = TRUE, legend = "bottom")

```


### Accessory

```{r accessory taxa from rare trim}

ps_rare_trim_otu <- data.frame(phylo_trim_rare@otu_table)
core_tax <- as.data.frame(tax_table(pseq_core)[,1:6]) # for some reason, the species and seqs columns are preventing the dataframe so cutting them
core_ids <- c(rownames(core_tax)) # pull ASVs that are core
ps_rare_trim_acc_otu <- ps_rare_trim_otu[,!colnames(ps_rare_trim_otu) %in% core_ids ] # select for non-core ASVs
# rownames(samdf_cleanest) <- samdf_cleanest$sampleID # don't think I need this


#remake phyloseq object with just accessory
phylo_acc <- phyloseq(otu_table(ps_rare_trim_acc_otu, taxa_are_rows = FALSE), 
                         sample_data(samdf_cleanest), 
                         tax_table(taxa_clean))
phylo_acc # 406 taxa accessory


#not rel abun
phylo_acc_ord <- plot_ordination(phylo_acc, ordinate(phylo_acc,"PCoA", "bray"), color="Treatment", shape="Genotype", justDF = TRUE) 
eigvec_acc <- ordinate(phylo_acc,"PCoA", "bray")$values["Eigenvalues"]
percvar_acc <- round(100 * eigvec_acc[1:2,]/sum(eigvec_acc), 1)

acc_plot <- ggplot(data = phylo_acc_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, shape = Genotype, group = Treatment)) +
  geom_point(color = "black", size = 4) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  #scale_shape_manual(values = gen_shape) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(fill = "none") +
  labs(x = paste0("Axis 1 (", percvar_acc[1], "%)"),
       y = paste0("Axis 2 (", percvar_acc[2], "%)")) +
  ggtitle("D.   Accessory taxa")
acc_plot


#rel abun
phylo_acc_rel <- transform_sample_counts(phylo_acc, function(x) x / sum(x))
phylo_acc_rel_ord <- plot_ordination(phylo_acc_rel, ordinate(phylo_acc_rel,"PCoA", "bray"), color = "Treatment", shape = "Genotype", justDF = TRUE) 
eigvec_acc_rel <- ordinate(phylo_acc_rel,"PCoA", "bray")$values["Eigenvalues"]
percvar_acc_rel <- round(100 * eigvec_acc_rel[1:2,]/sum(eigvec_acc_rel), 1)

rel_acc_plot <- ggplot(data = phylo_acc_rel_ord, aes(x = Axis.1, y = Axis.2, colour = Treatment, fill = Treatment, shape = Genotype, group = Treatment)) +
  geom_point(color = "black", size = 4) +
  stat_ellipse()+
  theme_bw()+
  theme(panel.grid = element_blank()) +
  #scale_shape_manual(values = gen_shape) +
  scale_color_manual(values = trt_col) +
  scale_fill_manual(values = trt_col) +
  guides(fill = "none") +
  labs(x = paste0("Axis 1 (", percvar_acc_rel[1], "%)"),
       y = paste0("Axis 2 (", percvar_acc_rel[2], "%)")) +
  ggtitle("D.   Accessory taxa (relative abundance)")

```

#### Accessory stats

```{r accessory stats for rare}

### Dispersion stats of accessory taxa 
seq_acc <- data.frame(otu_table(phylo_acc)) # pull the otu table from the acc object
dist_acc <- vegdist(seq_acc) # calculate Bray-Curtis distances between samples
samdf_acc <- data.frame(sample_data(phylo_acc)) # pull sample data from the acc phyloseq object
bet_acc <- betadisper(dist_acc, samdf_acc$Treatment)


# Run the ANOVA
acc_anova <- anova(bet_acc)
acc_anova
plot(bet_acc) # plot the treatments and distances to centroids on the
boxplot(bet_acc) # boxplot of the distances to centroid for each treatment

## Dispersion by genotype: not significant 
#bet_acc_gen <- betadisper(dist_acc, samdf_acc$Genotype)
#anova(bet_acc_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_acc, pairwise = TRUE, permutations = 999) # not significant
#permutest(bet_acc_gen, pairwise = TRUE, permutations = 999) # not significant

### Multivariate stats (PERMANOVA)
acc_adonis <- adonis2(seq_acc ~ Treatment + Genotype, data = samdf_acc, permutations = 1500)
acc_adonis

```

```{r accessory stats for rel abund}

## Dispersion stats of accessory taxa by relative abundance
seq_acc_rel <- data.frame(otu_table(phylo_acc_rel))
dist_acc_rel <- vegdist(seq_acc_rel) # calculate Bray-Curtis distances between samples
bet_acc_rel <- betadisper(dist_acc_rel, samdf_acc$Treatment)


# Run the ANOVA
acc_rel_anova <- anova(bet_acc_rel)
acc_rel_anova
plot(bet_acc_rel) # plot the treatments and distances to centroids on the
boxplot(bet_acc_rel) # boxplot of the distances to centroid for each treatment

## Dispersion by genotype: not significant 
#bet_rel_acc_gen <- betadisper(dist_acc_rel, samdf_acc$Genotype)
#anova(bet_rel_acc_gen)

## Test of pairwise (treatment and genotype models)
#permutest(bet_acc_rel, pairwise = TRUE, permutations = 999) # not significant
#permutest(bet_rel_acc_gen, pairwise = TRUE, permutations = 999) # not significant

### Multivariate stats (PERMANOVA)
acc_rel_adonis <- adonis2(seq_acc_rel ~ Treatment + Genotype, data = samdf_acc, permutations = 1500)
acc_rel_adonis

```

```{r accessory stat and PCA comparison}

## Add the stats to the acc PCA plot (rarefied data)
acc_disp_pval <- substitute(italic(P[disp])==p, list(p = format(acc_anova[[1,5]], digits = 2)))
acc_trt_pval <- substitute(italic(P[treat])==p, list(p = format(acc_adonis[[1,5]], digits = 2)))
acc_gen_pval <- substitute(italic(P[genotype])==p, list(p = format(acc_adonis[[2,5]], digits = 2))) 

acc_stat_plot <- acc_plot +
  annotate("text", x = 0.6, y = 0.25, label = deparse(acc_disp_pval), parse = TRUE, size = 4) +
  annotate("text", x = -0.8, y = -0.24, label = deparse(acc_trt_pval), parse = TRUE, size = 4) +
  annotate("text", x = -0.8, y = -0.26, label = deparse(acc_gen_pval), parse = TRUE, size = 4) 


## Add the stats to the acc PCA plot (rel abund data)
rel_acc_disp_pval <- substitute(italic(P[disp])==p, list(p = format(acc_rel_anova[[1,5]], digits = 2)))
rel_acc_trt_pval <- substitute(italic(P[treat])==p, list(p = format(acc_rel_adonis[[1,5]], digits = 2)))
rel_acc_gen_pval <- substitute(italic(P[genotype])==p, list(p = format(acc_rel_adonis[[2,5]], digits = 2)))

rel_acc_stat_plot <- rel_acc_plot +
  annotate("text", x = -0.6, y = 0.13, label = deparse(rel_acc_disp_pval), parse = TRUE, size = 4) +
  annotate("text", x = 0.7, y = -0.19, label = deparse(rel_acc_trt_pval), parse = TRUE, size = 4) +
  annotate("text", x = 0.7, y = -0.21, label = deparse(rel_acc_gen_pval), parse = TRUE, size = 4) 

### Combine plots and make decision
ggarrange(acc_stat_plot, rel_acc_stat_plot, common.legend = TRUE, legend = "bottom")

```

<br/>
<br/>


## Differentially abundant taxa {.tabset}

Performing this analysis with ANCOM and a tutorial for it can be found [here](https://github.com/FrederickHuangLin/ANCOM). I am mostly following Nicola's code from her Moorea paper.

```{r ancom all, eval=FALSE}

# reloading the trimmed phylo data to be safe!
load("Data/16S_data/phylo_clean.Rdata")

otu_data_unt <- data.frame(phylo_cleanest@otu_table)
otu_data<- data.frame(t(otu_data_unt)) # transpose and make into data frame

# read in the meta data from the phyloseq object
meta_data <- data.frame(phylo_cleanest@sam_data)

### Step 1: Data preprocessing
# set objects going into feature_table_pre_process() function
feature_table = otu_data; sample_var = "sampleID"; group_var = NULL
out_cut = 0.05; zero_cut = 0.90; lib_cut = 1000; neg_lb = FALSE

prepro <- feature_table_pre_process(feature_table, meta_data, sample_var, group_var, out_cut, zero_cut, lib_cut, neg_lb)
feature_table <- prepro$feature_table # Preprocessed feature table
meta_data <- prepro$meta_data # Preprocessed metadata
struc_zero = prepro$structure_zeros # Structural zero info


### Step 2: ANCOM
# set objects going into ANCOM() function
main_var = "Treatment"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula = NULL
res_all <- ANCOM(feature_table, meta_data, struc_zero, main_var, p_adj_method, 
                alpha, adj_formula, rand_formula)
save(res_all, file = "Data/16S_data/ancom_results.Rdata")


# ### Step 3: Volcano Plot
# # Number of taxa except structural zeros
# n_taxa <- ifelse(is.null(struc_zero), nrow(feature_table), sum(apply(struc_zero, 1, sum) == 0))
# 
# # Cutoff values for declaring differentially abundant taxa
# cut_off <- c(0.9 * (n_taxa -1), 0.8 * (n_taxa -1), 0.7 * (n_taxa -1), 0.6 * (n_taxa -1))
# names(cut_off) <- c("detected_0.9", "detected_0.8", "detected_0.7", "detected_0.6")
# 
# # Annotation data
# dat_ann <- data.frame(x = min(res_all$fig$data$x), y = cut_off["detected_0.7"], label = "W[0.7]")
# fig <- res_all$fig +  
#   geom_hline(yintercept = cut_off["detected_0.7"], linetype = "dashed") + 
#   geom_text(data = dat_ann, aes(x = x, y = y, label = label), 
#             size = 4, vjust = -0.5, hjust = 0, color = "orange", parse = TRUE)
# fig  

```

No differentially abundant taxa were identified! 

<br/>
<br/>


# **ITS2 Assessment** {.tabset}

```{r cleaning up its2 file, eval=FALSE, include=FALSE}

df <- read.table("Data/ITS2_data/213_20220723T083504_DBV_20220723T141453.profiles.absolute.abund_and_meta.txt", sep = "\t")[c(-1:-6,-44, -45),-1] %>%
  row_to_names(row_number = 1)

names(df)[1] <- "sampleID"

write.csv(df, "Data/ITS2_data/ITS2_symportal.csv", row.names = FALSE)

```

```{r read in ITS2 data}

## read in ITS2 data
its_df <- read.csv("Data/ITS2_data/ITS2_symportal.csv") %>% 
  column_to_rownames("sampleID") # making first column of sample IDs the rownames

## read in the meta data from the samples
meta <- read.csv("Data/Acerv_MP_Metadata.csv") %>% 
  column_to_rownames("sampleID") %>% # making first column of sample IDs the rownames
 # filter(Genotype %in% keep_samples) %>% # select for only the GE matching samples (defined above)
  filter(Treatment != "blank_control") %>% # and remove the neg controls
  separate(Genotype, c("Genotype", "Frag"), sep = "(?=[A-Z])") 

```

```{r its2 phyloseq object}

## Make taxa table for phyloseq
taxa_its <- data.frame(colnames(its_df))# extract symb strain data as dataframe
colnames(taxa_its) <- "DIV" # changing the column name to be 'DIV'
taxa_its[2] <- taxa_its %>% separate(DIV, "majority_its2") # create a column for major ITS2 (first part of DIV name)
taxa_its$genus <- str_sub(taxa_its$DIV, 1, 1) # make genus column of symb genus (first letter of DIV)
taxa_its <- taxa_its %>% mutate_if(is.character, as.factor) # convert all columns to factors
rownames(taxa_its) <- taxa_its$DIV # rename rows with DIV ids
taxa_its_matrix <- as.matrix(taxa_its) # convert to a matrix
 

## Create ITS2 taxa phyloseq object 
phylo_its2 <- phyloseq(sample_data(meta),
                       otu_table(its_df, taxa_are_rows = FALSE),
                       tax_table(taxa_its_matrix))
# phylo_its2 # just a sanity to check that we have 6 taxa and 19 samples -- Looks good!

```

### Abundance by treatment and genotype

```{r calc rel abund and save phylo objc, fig.height = 4, fig.width = 6, fig.align = "center"}

## Calculate relative abundance per sample
phylo_its2_rel <- transform_sample_counts(phylo_its2, function(OTU) OTU/sum(OTU))

## plot relative majority ITS2 by treatment
plot_bar2(phylo_its2_rel, x = "Genotype", fill = "majority_its2", colour = "majority_its2")+
  theme_bw() +
  facet_wrap(~ Treatment, ncol = 2) +
  theme(panel.grid = element_blank(), legend.position = "bottom", strip.background = element_blank(), strip.text = element_text(face = "bold")) +
  labs(x = "", y = "Relative abundance") +
  scale_color_manual("Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_fill_manual( "Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.02))

ggsave("Figures/Supplemental/FigSXX_ITS2_GenxTrt.png", height = 4, width = 6, dpi = 600)
ggsave("Figures/Supplemental/FigSXX_ITS2_GenxTrt.pdf", height = 4, width = 6, useDingbats = FALSE)

## Save both the absolute and relative abundance phyloseq objects
#save(phylo_its2, phylo_its2_rel, file = "Data/ITS2_data/its_phylo_abund.Rdata")

```

**Figure SXX.** Relative abundance of major ITS2 types by coral fragment (x axis) and treatment (facets). Light green represent *Symbiodinium* spp. (A3) and dark green represents *Breviolum* spp. (B2).

<br/>
<br/>


### Abundance by treatment only

```{r treatment level abundance, fig.height = 4, fig.width = 4, fig.align = "center"}

#load(file = "Data/ITS2_data/its_phylo_abund.Rdata")

## Calculate relative majority ITS2 by treatment
its2_major <- tax_glom(phylo_its2, "majority_its2") # merge samples with same 'majority_its2' rank
its2_major_rel <- transform_sample_counts(its2_major, function(x) x / sum(x)) # summarize rel abundance 
its_major_trt <- merge_samples(its2_major_rel, "Treatment") # merge samples with same treatment 
its_rel_trt <- transform_sample_counts(its_major_trt, function(x) x / sum(x)) # summarize rel abundance 
its_rel_trt@sam_data[["Treatment"]] <- levels(phylo_its2_rel@sam_data[["Treatment"]]) # need to rename treatment levels

## plot relative majority ITS2 by treatment
plot_bar2(its_rel_trt, x = "Treatment", fill = "majority_its2", colour = "majority_its2")+
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "bottom") +
  labs(x = "", y = "Relative abundance") +
  scale_color_manual("Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_fill_manual( "Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01))

```

<br/>
<br/>


# **Manuscript Materials**

## Methods {.tabset}

### ITS2 and 16S metabarcoding

DNA was extracted using an RNAqueous kit (ThermoFisher Scientific) as described above, except samples were not subjected to the DNA removal step. Internal transcribed spacer region 2 (ITS2) PCR amplification was performed using SYM_VAR_5.8S2 and SYM_VAR_REV primers (as described in Hume et al. 2013, 2015) using the following PCR profile: 26 cycles of 95℃ for 40 s, 59℃ for 2 min, 72℃ for 1 min and a final extension of 72℃ for 7 min. A negative control was included and it failed to amplify so it was not sequenced. PCR products were cleaned using the GeneJET PCR Purification kit (ThermoFisher Scientific) according to the manufacturer’s instructions. A second PCR was performed to dual-barcode samples before pooling, which was done based on the visualization of band intensity on a 1% agarose gel. 20 μl of the pool was run on a 2% SYBR Green gel for 100 min at 70 V. The target band was excised and placed in 30 μl of Milli-Q water overnight at 4℃. The supernatant concentration was measured using a DeNovix DS-11+ Spectrophotometer.   

The V4 region of the 16S rRNA gene was amplified via PCR using Hyb515f and Hyb806R primers (Parada et al. 2016, Apprill et al. 2015) and the following PCR profile: 30 cycles of 95℃ for 40 s, 63℃ for 2 min, 72℃ for 1 min and a final extension of 7 min. Two negative controls using Milli-Q water were also prepared during the 16S library preparations and these samples were also sequenced. The same procedure as described above for the ITS2 samples was then followed. Concentrations of the ITS2 and 16S pools were used to combine the two pools in a 1:3 ratio respectively. Libraries were sequenced on Illumina MiSeq (paired-end 250 bp) at Tufts Genomics Core Facility. 


### ITS2 and 16S analyses

Demultiplexed reads were pre-processed using bbmap (**CITE**) to remove adapters and to split ITS2 and 16S reads based on primers. Resulting ITS2 reads were then analyzed using the SymPortal framework (Hume et al., 2019) by submitting paired fastq.gz files directly to SymPortal. Samples were subjected to standard sequence quality control protocols using MOTHUR 1.39.5 (Schloss et al., 2009), the BLAST+ suite of executables (Camacho et al., 2009), and minimum entropy decomposition (Eren et al., 2015). SymPortal identifies specific sets of defining intragenomic ITS2 sequence variants (DIVs) to define ITS2 type profiles that are indicative of genetically differentiated Symbiodiniaceae taxa (Hume et al., 2019). 

16S primers were removed using cutadapt (**CITE**) and DADA2 (**CITE**) was used to conduct quality filtering and inference of `r dim(phylo_sp@otu_table)[2]` amplicon sequence variants (ASVs) (see Table SXX to track reads lost through filtering). 16S taxonomy was assigned using the Silva v. 138.1 database (**CITE**) and National Center for Biotechnology Information’s nucleotide database using blast+ (**CITE**). ASVs matching mitochondria, chloroplasts, or non-bacterial kingdoms were removed (`r contam_tot` total) and `r neg_contam[[2]]` ASVs were removed based on negative controls as contaminants (*Decontam*; (**CITE**)). Cleaned counts were then rarefied to `r raremax` per sample using vegan (**CITE**), trimmed using MCM.OUT (**CITE**) to remove ASVs present in less than 0.01% of counts, and then rarefied again to `r raremax_trim` resulting in `r dim(phylo_trim_rare@otu_table)[2]` ASVs. **DIVERSITY AND COMMUNITY ANALYSES**

<br/>
<br/>


## Results {.tabset}

### Symbiodiniaceae community composition

Statement of raw counts. After classification by Symportal, ITS2 counts ranged from 730–121,515 per sample across all 36 samples with a mean of 32,774 counts. All coral individuals hosted *Symbiodinium ‘fitti’* (ITS2 type A3) with 44% of individuals (n=16) hosting small background amounts of *Breviolum minutum* (ITS2 type B2).

<br/>


### *Acropora cervicornis* fragments are dominated by order Rickettsiales

Trimmed and rarified 16S reads averaged `r format(round(mean_preRare, 0), scientific = FALSE)` ± `r format(round(sd_preRare, 0), scientific = FALSE)` (±SD) per sample across all *A. cervicornis* samples with a minimum of `r format(min(preRare_count), scientific = FALSE)` (Sample `r as.character(track_reads$Sample[track_reads$"Sample ID" == min_sample])`) and a maximum of `r format(max(preRare_count), scientific = FALSE)` (Sample `r as.character(track_reads$Sample[track_reads$"Sample ID" == max_sample])`). Fragments were dominated by taxa from the phylum Proteobacteria (**Figure 5A**), which was dominated by a single ASV (Genus MD3-55; Ca. Aquarickettsia) within the order Rickettsailes (**Figure 5B**; see **Supplemental Figure XX**). Beta diversity analyses did not identify any statistical differences across samples based experimental treatment or genotype (**Figure 5C and Table SXX**). Similarly, alpha diversity was indistinguishable across treatments (**Supplemental Figure SXX and Table SXX**). After removing Aquarickettsia from all samples to assess background bacterial communities, there were still no differences in alpha and beta diversity across treatments or genotypes (**Supplemental Figure SXX and Table SXX**).

<br/>
<br/>




## Figures {.tabset}

### Figure 2

```{r figure 4, fig.height = 4, fig.width = 4}

plot_bar2(its_rel_trt, x = "Treatment", fill = "majority_its2", colour = "majority_its2")+
  theme_bw() +
  theme(panel.grid = element_blank(), legend.position = "bottom") +
  labs(x = "", y = "Relative abundance") +
  scale_color_manual("Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_fill_manual( "Majority ITS2", values = c("#9e9ac8", "#54278f")) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 1.01))

ggsave("Figures/Fig2_ITS2.png", height = 4, width = 4, dpi = 600)
ggsave("Figures/Fig2_ITS2.pdf", height = 4, width = 4, useDingbats = FALSE)

```

**Figure 2.** Relative abundance of major ITS2 types grouped by treatment (n = 4-5 corals per treatment). Light purple represents *Symbiodinium fitti* (A3) and dark purple represents *Breviolum minutum* (B2).

<br/>
<br/>


### Figure 5

```{r fig 5a phylum barplot}

trim_rare_rel_phyla2 <- trim_rare_rel_phyla + 
  theme(strip.background = element_blank()) +
  ggtitle("Rarefied ASVs (phylum)")

```

```{r fig 5b Proto bacteria}

proteo_plot2 <- proteo_plot + 
  theme(strip.background = element_blank()) +
  ggtitle("Protobacteria ASVs (order)")

```

```{r fig 5c PCoA}

## Add the stats to the core PCA plot (rarefied data)
core_disp_pval <- substitute(italic(P[disp])==p, list(p = format(core_anova[[1,5]], digits = 2)))
all_trt_pval <- substitute(italic(P[treat])==p, list(p = format(all_adonis[[1,5]], digits = 2)))
all_gen_pval <- substitute(italic(P[genotype])==p, list(p = format(all_adonis[[2,5]], digits = 2))) 

## update plot
pcoa_all2 <- pcoa_all + 
  #annotate("text", x = -0.8, y = 0.15, label = deparse(rel_core_disp_pval), parse = TRUE, size = 3) +
  annotate("text", x = -0.47, y = -0.49, label = deparse(all_trt_pval), parse = TRUE, size = 3) +
  annotate("text", x = -0.47, y = -0.53, label = deparse(all_gen_pval), parse = TRUE, size = 3) +
  theme(legend.position = c(0.17, 0.32))

```

```{r full fig 5, fig.height = 9, fig.width = 14}

## set the layout
layout5 <- "
AAAAAAAA
BBBBCCCD
"

## add plots together with layout
Figure5 <- trim_rare_rel_phyla2 + proteo_plot2 + pcoa_all2 + dist_plot + plot_layout(design = layout5) + plot_annotation(tag_levels = 'A')
Figure5

## save figure 
ggsave("Figures/Figure5_16s_diversity.png", height = 9, width = 14, dpi = 600)
ggsave("Figures/Figure5_16s_diversity.pdf", height = 9, width = 14, useDingbats = FALSE)

```

**Figure 5:** *Acropora cervicornis* bacterial (16S) relative abundance across fragments and experimental treatments. Diversity at the phylum level (**A**) depicts dominance of all samples by taxa from Proteobacteria and this (**B**) phylum was dominated by the order Rickettsiales in most samples. Beta diversity was visualized through (**C**) multivariate ordination plots (PCoA) of between-sample Bray–Curtis dissimilarity of rarefied ASVs of all taxa and (**D**) distance to treatment centroids. PCoA ellipses depict 95% confidence intervals and p-values indicate significance of treatment and genotype.

<br/>
<br/>


## Supplemental figures {.tabset}

### Figure SXX

```{r fig SXX alpha diversity, fig.align = 'center', fig.height = 7, fig.width = 8}

figSX <- ggarrange(simp_stat_plot, shan_stat_plot, rich_stat_plot, even_stat_plot, common.legend = TRUE, labels = "AUTO", legend = "none") 
figSX

## save figure 
ggsave("Figures/Supplemental/FigureSX_alpha.png", height = 7, width = 8, dpi = 600)
ggsave("Figures/Supplemental/FigureSX_alpha.pdf", height = 7, width = 8, useDingbats = FALSE)

```

**Figure SX** Alpha diversity metrics across all samples in all treatments, depicting (**A**) Simpson index, (**B**) Shannon index, (**c**) species richness (ASVs), and (**D**) Evenness.

<br/>
<br/>


### Figure SXX

```{r fig SXX , fig.align = 'center', fig.height = 7, fig.width = 8}

# ## save figure 
# ggsave("Figures/Supplemental/FigureSX_alpha.png", height = 7, width = 8, dpi = 600)
# ggsave("Figures/Supplemental/FigureSX_alpha.pdf", height = 7, width = 8, useDingbats = FALSE)

```

**Figure SX** Alpha diversity metrics across all samples in all treatments, depicting (**A**) Simpson index, (**B**) Shannon index, (**c**) species richness (ASVs), and (**D**) Evenness.

<br/>
<br/>


## Supplemental tables {.tabset}

```{r}

```

<br/>
<br/>


# Session Information

All code was written by [Colleen B. Bove](https://colleenbove.science), feel free to contact with questions.

Session information from the last run date on `r format(Sys.time(), '%d %B %Y')`:

```{r print session info}

sessionInfo()

```
